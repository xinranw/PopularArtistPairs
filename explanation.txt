To run the program, run the following command in the folder directory:
  ruby knewton.rb

Explanation:

This program first imports the txt file with user and artist information by calling the importFile method. A new User object is created for each row of the text file, containing a Set representation of his favorite artists. This step iterates through each line of the file and splits each line of artists into an array. If n = number of lines and m = max number of artists for a given user, this will run in O(n*m) time and will create the @users variable with O(n*m) space complexity.

After the @users "database" has been created, a dictionary of artists to number of times they appear in the list is generated by the fillArtistDict method. This function iterates through @users to create the dictionary then calls trimDict to remove all artists that appear less than 50 times total. This will help reduce the number of artists that will need to be checked later. This step runs in O(n*m) time with a space complexity of O(n*m).

The trimDict function runs in linear time as it iterates through the Hash object to remove all key-value pairs whose value is less than the minVal.

The getPairs function generates a dictionary of pairs of artists versus their frequency. The pairs are generated as Set objects to eliminate the problem of ordering. This function first creates the pop_artists Set from the keys of @artists_dict. Then it iterates through the users, filtering out each users' artists that isn't in @artists_dict by using Set intersection, and skipping the users that have one or fewer artists. This step is aimed to reduce the number of pairings that have to be checked in the next step. After this, for each users' artists, all pairings are generated and added to @popular_pairs as the key, while incrementing the value as a counter. After @popular_pairs has been populated, trimDict is called again to remove all pairs that occur less than 50 times.
The method getPairs represents the rate limiting step in this program. There's one loop for iterating through @users, and two more loops when pairs are generated. Thus this step is in O(n*m^2) time, where n = number of users and m = max number of artists in a user. Here, I have aimed to minimize n and m by the filtering steps explained above. The space usage is also rather inefficient here as an array is used for each users' artists to use the Array.combination method to generate artist pairings.

Lastly, outputPopularPairs iterates through the @popular_pairs dictionary to output the results to stdout. This is performed in O(n) time where n = number of keys in @popular_pairs.
